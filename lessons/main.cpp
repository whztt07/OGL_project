/* 
	Данный код является результатом уроков по OpenGL. Он не связан с проектом напрямую, но помогает понять базовые принципы работы с OpenGL.
	Так как код является по большей части наглядным пособием, он изобилует комментариями разной степенью очевидности, вплоть до "это и ежу ясно". Я предупредил.
	Оригинальный сайт с уроками: http://ogldev.atspace.co.uk/index.html
	Переводы: http://triplepointfive.github.io/ogltutor/
*/

#include <stdio.h>
#include <gl/glew.h> /* 
						Обеспечивает эффективные run-time механизмы для определения того, какие OpenGL расширения поддерживаются на целевой платформе. 
						Если вы подключаете другие заголовки OpenGL, вам следует подключить его раньше остальных, иначе GLEW откажется работать. 
					*/
#include <gl/GL.h> /* 
						Сам OpenGL 
					*/
#include <gl/freeglut.h> /* 
						API для управления оконной системой, а так же обработка событий, контроль ввода/вывода и ещё несколько других возможностей 
					*/
#include "math_3d.h" /* 
						Кастомный заголовок, постепенно увеличивающийся в ходе обучения 
					*/

#pragma comment(lib, "glew32.lib") /* 
						Автоматическая линковка glew32.lib для работы с GLEW 
					*/

GLuint VBO; /* Глобальная переменная для хранения указателя на буфер вершин */

static void RenderSceneCB()
{
	glClear(GL_COLOR_BUFFER_BIT);

	glEnableVertexAttribArray(0); // Разрешаем использование атрибута вершины для доступа к нему через конвеер. Это необходимо для шейдеров
	glBindBuffer(GL_ARRAY_BUFFER, VBO); // Привязываем указатель для отрисовки кадра
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0); // Этот вызов говорит конвейеру как воспринимать данные внутри буфера.

	glDrawArrays(GL_POINTS, 0, 1);

	glDisableVertexAttribArray(0); /*
										Это признак хорошего тона отключать каждый атрибут вершины, как только отпадает необходимость в нем. 
										Оставить его включенным, пока шейдер не используется - лучший способ получить проблем.
								   */

	glutSwapBuffers(); /*
							После рисования нужно просить OpenGL сменить экранные буфера при помощи glutSwapBuffers (), ведь у нас включена двойная буферизация. 
							Все рисуется на скрытом от пользователя буфере и затем происходит смена буферов. 
							Делается это для получения плавной анимации и для того, чтобы не было эффекта мерцания экрана.
					   */
}


static void InitializeGlutCallbacks()
{
	glutDisplayFunc(RenderSceneCB);
}

static void CreateVertexBuffer()
{
	Vector3f Vertices[1];
	Vertices[0] = Vector3f(0.0f, 0.0f, 0.0f);

	glGenBuffers(1, &VBO); // Создаем буфер в общем типе. Для указания задачи используется следующая функция.
	glBindBuffer(GL_ARRAY_BUFFER, VBO); // Привязываем указатель для наполнения данными
	glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW); // После связывания нашего объекта, мы наполняем его данными.
}


int main(int argc, char** argv)
{
	glutInit(&argc, argv); // Инициализируем GLUT
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA); /*
														Так настраиваются некоторые опции GLUT. 
														GLUT_DOUBLE включает двойную буферизацию (отрисовка будет происходить в фоновый буфер, в то время как другой буфер отображается) 
														и буфер цвета, непрерывно используемого для конечной цели рендеринга (т.е. на экране).
												  */
	glutInitWindowSize(800, 600);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("Tutorial XX"); // Здесь задается заголовок окна. В оригинальных уроках у каждого туториала есть индивидуальный двузначный номер. Здесь он заменен на ХХ.

	InitializeGlutCallbacks(); // Большая часть взаимодействий с системой происходит через функции обратного вызова

	/* Теперь мы инициализируем GLEW и проверяем на ошибки. GLUT необходимо инициализировать раньше. */
	GLenum err = glewInit();
	if (err != GLEW_OK) {
		fprintf(stderr, "Error: '%s'\n", glewGetErrorString(err));
		return 1;
	}

	glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // Установка "чистого" цвета фона

	CreateVertexBuffer();

	glutMainLoop(); /*
						Этот вызов передаёт контроль GLUT’у, который теперь начнёт свой собственный цикл. 
						В этом цикле он ждёт событий от оконной системы и передаёт их через функции обратного вызова, которые мы задали ранее.
					*/

	return 0;
}